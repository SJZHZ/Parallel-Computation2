# 并行计算 II 2023 春季第一次作业：<br> OpenMP 优化 Bellman-Ford 算法

## 1. Bellman-Ford 算法
> 单源最短路径，以0点为起点，通过邻接矩阵更新距离向量  
> 输入：邻接矩阵mat  
> 输出：距离向量d  
> 
> 算法：  
> > 初始化：d[0]=0  
> 状态转移：d[x] = min(d[x], d[y]+w[y][x])  
> 终止条件：在某次迭代后没有发生更新，或已迭代了n-1轮。  
> > > 此时需要多迭代一轮，判定负权。

## 2. 串行计算
    见serial.cpp

## 3. 并行计算
> 状态转移：d[x] = min(d[x], d[y]+w[y][x])

基于上述状态转移过程，各状态可以独立计算。但必须注意：

1. 最外层循环即迭代轮数不可作并行，而两层内层循环则可以**选择性地作并行**。
2. 算法的一个终止条件是基于最短路径长度不超过n，这要求我们必须保证遍历过路径长为n的所有路径，对变量之间限定了一定的依赖关系。如果是完全独立地计算，可能某一点在计算了n步后其他点都还未开始，这将导致不能给出正确的结果。因此，在每轮迭代后需要作**栅栏同步**。
3. 对串行计算而言，每轮迭代更新的内层两重循环——途径点和终点，遍历顺序并无区别。而对并行计算而言，**遍历顺序有区别**。