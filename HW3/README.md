# # 并行计算 II 2023 春季第三次作业：<br> 优化 Gaussian Blur 算子
**1900017702 朱越**
## 0. 概要
本作业选择使用MPI+OpenMP混合方式对Gaussian Blur算子进行优化

## 1. Gaussian Blur算子
使用3\*3卷积核对N\*M矩阵作卷积，不进行padding操作，得到(N-2)\*(M-2)矩阵
        $$
        \frac{1}{16}
        \left(
        \begin{matrix}
        1 & 2 & 1\\
        2 & 4 & 2\\
        1 & 2 & 1\\
        \end{matrix}
        \right)
        $$
## 2. 串行计算
源码见gaussian_blur.cpp，核心部分如下：
```cpp
for (int j = 1; j < width - 1; ++j)
{
    for (int i = 1; i < height - 1; ++i)
    {
        double pixel = 0.0;
        for (int l = -1; l <= 1; ++l)
            for (int k = -1; k <= 1; ++k)
                pixel += image[i + k][j + l] * KERNEL[k + 1][l + 1];
        blurredImage[i][j] = pixel / 16.0;
    }
}
```
一次运行时间大约是5.4s
## 3. 思考题：
* Gaussian blur是属于运算密集型还是访存密集型应用？为什么？
* 答：是访存密集型应用。假设不利用任何时空局部性，
## 4. 并行计算
1. 编译优化
    * 使用-Ofast编译优化选项，平均用时减少到2.4s
2. 节点与核心，进程与线程
    > 先考虑使用OpenMP作多线程并行，这在编程上最简单。测试发现，单节点16线程运行时间只有约0.5s，而且是在十张图片上的总时长，平均每张图片上的用时只有50ms。在这么多节点上的同步反而更浪费时间（总时长约1s），所以本次任务尽量使用单节点进行。
    >
    > 集群使用的物理节点是双路12核的E5-2650 v4，如果在一个节点上申请超过12个核心，就不得不分配到两个插槽上，不同插槽的共享内存访问比同一插槽的慢，这造成的性能损失比更多核心带来的计算负载减小更显著。因此，本次任务使用12个CPU核心，可以加速到约0.4s。
    > 
    > 在该问题中，恰当的任务划分可以使得各工作流之间不存在除RAR外的数据冲突，只需要对同一片共享内存的不同位置各自写入。多进程并行由于内存隔离性好而不适合这种情况（需要作显式的通信同步），而多线程并行则正好对应这样共享内存写的情况。因此，本次任务使用单进程多线程并行。
    * 使用单节点12核心作单进程多线程并行，可以加速到约0.4s
3. 遍历顺序
    > 对两重循环遍历i和j作工作分配时，可以选择遍历的顺序和划分方式。
    >
    > 首先，应该对外层循环作并行划分。划分外层和内层的区别在于所开辟的并行区是持久的还是临时的，临时的并行区需要每次初始化，而持久化的并行区则可以复用这部分重复工作。
    > 
    > 其次，输入和输出矩阵都是按行存储的。按行连续访问可以利用缓存的空间局部性，因此按列遍历放在外层，按行遍历放在内层的配置可以最大程度地利用空间局部性。
    * 使用i-j的遍历顺序，并对外层i作并行划分，可以加速到约0.08s

4. 循环展开
    1. 核展开
        > 由于本问题中的Gaussian核只有3*3大小，因此考虑直接把要累加的9项展开。实际测得并无明显效果，可能是编译器已经自动对定长且较短的循环作了展开。进一步在无编译优化选项的条件下进行测试，发现循环展开确实会带来效果。这证实了编译优化会作循环展开。
        >
        > 另一方面，我尝试了直接把Gaussian核的数值写入到循环中，试图减少访存消耗的时间，然而这并没有带来任何改变。这是由于开启编译优化的情况下，编译器会尽量把在编译时刻就能确定的计算提前在编译阶段完成，本问题中的对于常量矩阵KERNEL的元素取值就可以在编译阶段直接确定。
    2. 列展开
        > 在按列遍历时展开循环，或许可以减少跳转次数，并更精细化地利用到空间局部性。然而实测表明这种展开方式并不是一个理想的方向，其可能原因如下：如果不展开核所在的循环，单次循环工作量已经比较大，跳转带来的流水线损失不大，没有显著效果；如果展开核所在的循环（核展开），可以进一步利用数据的时间局部性，但反而造成了寄存器满溢，速度变慢。
    3. 行展开
        > 按行展开的情况比较特殊，因为现有的优化工作是建立在按行划分上的，因此展开已划分的循环相当于修改了划分。在下一小节中详细讨论划分情况。
5. 工作负载

## 5. 最终策略

## 6. 结果复现
编译
```zsh
make clean
make
```
测试
```zsh
sbatch run.slurm
```